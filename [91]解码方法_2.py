# -*- coding: utf-8 -*-

"""
@Time        : 2020/8/31
@Author      : jim
@File        : [91]解码方法
@Description : 
"""

'''
思路要清晰
由于当前字符串的可能情况，分为两种可能，1、当前字符单独编码 2、和前一个字符共同编码
比如：‘12’ 可以是‘1’‘2’也可以‘12’，所以状态方程应该是 DP[n] = F(DP[n-1],DP[n-2])
于是我们可以这样定义状态：DP[i]为到i为止，可能的编码数量，这里有个技巧，由于字符串从索引0开始，我们可以在DP最前面加一个辅助的数值DP[0]=1,DP数组的长度比字符串长1，然后就是根据所有的情况，处理当前字符的编码可能。
'''

def numDecodings(self, s: str) -> int:
    if s[0] == '0':return 0
    n = len(s)
    dp = [0]*(n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2,n+1):
        #第一种情况，连续两个0或者是大于20的整10数字，是无法编码的，直接返回0
        if s[i-1] == s[i-2] == '0' or (s[i-1] == '0' and int(s[i-2]) > 2):
            return 0
        #当前的字符为0，只能编码连续两位，因此dp[i] = dp[i-2]
        elif s[i-1] == '0':
            dp[i] = dp[i-2]
        #前一个字符为0，则当前只能编码一位，dp[i] = dp[i-1]
        elif s[i-2] == '0':
            dp[i] = dp[i-1]
        #当前连续两个字符在0-27之间，可以编码一个或者两个
        elif int(s[i-2] + s[i-1]) < 27:
            dp[i] = dp[i-1] + dp[i-2]
        #当前连续两个字符大于27，只能编码一个
        else:
            dp[i] = dp[i-1]
    return dp[n]

# 执行用时：32 ms, 在所有 Python3 提交中击败了98.43%的用户
# 内存消耗：13.7 MB, 在所有 Python3 提交中击败了51.65%的用户